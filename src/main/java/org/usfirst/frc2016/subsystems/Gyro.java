// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2016.subsystems;

import org.usfirst.frc2016.Config;
import org.usfirst.frc2016.Defaults;
import org.usfirst.frc2016.Robot;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.kauailabs.navx.frc.AHRS;
// import com.kauailabs.navx.frc.AHRS.SerialDataType;
//import com.sun.tools.javac.tree.JCTree.JCPolyExpression.PolyKind;

import edu.wpi.first.wpilibj.SPI;
// import edu.wpi.first.wpilibj.SerialPort;

/**
 *
 */
public class Gyro extends Subsystem {

    public double gyroP = 0.095;
    public double gyroTurnMax = 0.35;
    private final String GYRO_ANGLE = "Gyro Angle";
    private final String GYRO_ROLL = "Gyro Roll";

    // ADIS16448_IMU imu;
    // XRS450_Gyro digGyro;
    AHRS navxGyro = null;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public Gyro(boolean enable) {
        // digGyro = new ADXRS450_Gyro();
        // digGyro.calibrate();
        if (enable) {
            try {
                /* Communicate w/navX-MXP via the MXP SPI Bus. */
                /* Alternatively: I2C.Port.kMXP, SerialPort.Port.kMXP or SerialPort.Port.kUSB */
                /*
                 * See http://navx-mxp.kauailabs.com/guidance/selecting-an-interface/ for
                 * details.
                 */
                navxGyro = new AHRS(SPI.Port.kMXP);
                // navxGyro = new AHRS(SerialPort.Port.kUSB);
            } catch (RuntimeException ex) {
                DriverStation.reportError("Error instantiating navX-MXP:  " + ex.getMessage(), true);
                navxGyro = null;
            }
            reset();
        }
        /*
         * DriverStation.reportError("About to init ADIS16448", false); imu = new
         * ADIS16448_IMU();
         * 
         * if (imu == null) { // init failed
         * DriverStation.reportError("could not find ADIS16448", false); }
         */
    }

    public void periodic() {
        if (navxGyro != null) {
            SmartDashboard.putBoolean("NAV-X Connected", navxGyro.isConnected());
            // SmartDashboard.putData("IMU", imu);
            // sartDashboard.putNumber("Gyro Heading", digGyro.getAngle());
            SmartDashboard.putNumber("Gyro Heading", getAngle());
            // --SmartDashboard.putNumber("Roll", getRoll() );
        }
    }

    public void addTelemetryHeaders() {
        Robot.telem.addColumn(GYRO_ANGLE);
        Robot.telem.addColumn(GYRO_ROLL);
    }

    public void writeTelemetry() {
        if (navxGyro != null && Robot.isTelemetryEnbled) {

            Robot.telem.saveDouble(GYRO_ANGLE, getAngle());
            Robot.telem.saveDouble(GYRO_ROLL, getRoll());
        }
    }

    public void loadConfig(Config config) {
        gyroP = config.getDouble("gyroP", Defaults.GYROP);
        gyroTurnMax = config.getDouble("gryoTurnMax", Defaults.GYROTURNMAX);
    }

    public void calibrate() {
        // imu.calibrate();
        // gGyro.calibrate();
        // NavX doesn't appear to have a calibrate
    }

    /*
     * public double getAngle() { double angle; //turn digGyro.getAngle(); angle =
     * navxGyro.getAngle(); if (angle > 180) { angle = angle-360; } return angle; }
     */

    public double getAngle() {
        double angle = 0;
        if (navxGyro != null) {
            angle = navxGyro.getAngle();
        }
        return angle;
    }

    public double getRoll() {
        double angle = 0;
        if (navxGyro != null) {
            angle = navxGyro.getRoll();
        }
        return angle;
        // return -1.111111;

    }

    public void reset() {
        // gGyro.reset();
        // navxGyro.zeroYaw();
        if (navxGyro != null) {
            navxGyro.reset();
        }
    }

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
}
