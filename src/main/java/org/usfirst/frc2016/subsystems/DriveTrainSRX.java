// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2016.subsystems;

import org.usfirst.frc2016.commands.*;
import org.usfirst.frc2016.Constants;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.Encoder;
//import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.command.Subsystem;
//import edu.wpi.first.wpilibj.drive.DifferentialDrive;

import org.usfirst.frc2016.Config;
import org.usfirst.frc2016.Robot;
import org.usfirst.frc2016.Defaults;
import org.usfirst.frc2016.MMW_DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.can.TalonFX;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

import com.ctre.phoenix.motorcontrol.LimitSwitchNormal;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motion.SetValueMotionProfile;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
import com.ctre.phoenix.motorcontrol.LimitSwitchSource;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.sensors.PigeonIMU;

/**
 * @param <DifferentialDriveOdometry>
 *
 */
public class DriveTrainSRX extends Subsystem {
    static int finalLeft, finalRight;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonFX talonDriveLeft1;
    private WPI_TalonFX talonDriveLeft2;
    private WPI_TalonFX talonDriveRight1;
    private WPI_TalonFX talonDriveRight2;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private MMW_DifferentialDrive differentialDrive;
    PigeonIMU pidgy;
    // private final MMW_DifferentialDrive differentialDrive =
    // RobotMap.driveTrainSRXDifferentialDrive;
    // private final DifferentialDrive driveTrainSRXDifferentialDrive;
    // private final DifferentialDrive differentialDrive = new
    // DifferentialDrive(talonDriveLeft1, talonDriveRight1);
    // private final DifferentialDrive differentialDrive =
    // driveTrainSRXDifferentialDrive;

    // private final RobotDrive robotDrive = RobotMap.drivetrainRobotDrive;
    private final double SPEED_P = .15;
    private final double SPEED_I = .05;
    private final double speedFeedForward = .6;

    // Encoder counts / inch of travel
    public static final double COUNTS_PER_INCH = 885.86;
    private static final double SEC_PER_100MS = 0.1;

    // conversion between inches/sec -> falcon speed setting
    public static final double SPEED_SCALE = COUNTS_PER_INCH * SEC_PER_100MS;

    // parameters for determining when move is completed
    private final int MAX_POSITION_ERROR = (int) (.25 * COUNTS_PER_INCH);
    private final int STUCK_ENCODER_LIMIT = 10; // counts changing less than limit are considered 'stuck'
    private final int STUCK_MAX_COUNT = 20; // number of periodic scans before indicating 'stuck'
    private final int STUCK_START_IGNORE = 25; // number of periodic scans before detecting 'stuck'

    private final int pidSlot0 = 0;
    private final int timeoutMs = 0;

    /*
     * The following block of variables are used to hold values loaded from NV RAM
     * by RobotPrefs.
     */
    public double drivetrainVoltageLimit;
    public double rampIncrement;
    public double driveP;
    public double driveI;
    public double driveD;
    public double driveF;
    public int cruiseVelocity;
    public int acceleration;
    public boolean joySquare;
    /*
     * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ End of values set by RobotPrefs
     */

    public double driver_max_velocity = 100; // inches per second
    public double driver_max_accel = 1000; // inches per second squared

    // private double lastDesiredSpeed = 0;

    private double leftCurrentSpeed = 0;
    private double rightCurrentSpeed = 0;

    private double lastJoyLeft, lastJoyRight;
    private String lastDriveMode;
    private double lastRightCount, lastLeftCount, stuckCount, stuckStartCount;
    private double accumSpeed = 0;

    private double lastEndDistanceLeft = 0;
    private double lastEndDistanceRight = 0;

    StringBuilder _sb = new StringBuilder();
    int _loops = 0;

    private final DifferentialDriveOdometry m_odometry;

    private final ADXRS450_Gyro m_gyro = new ADXRS450_Gyro();

    /*
     * Magic Motion vales
     * 
     * Cim max no load speed 5330 Cim load speed 5330 * .9 = 4797 Gear box 6.66:1
     * 4797/6.66 = 720.2 RPMs 720.2/60 = 12.0 RPS 4096 counts/rev * 12.0 RPS =
     * 49,152 Counts / second 49152/1000*100 = 4915.2 Revs Per 100ms SRX intrnal
     * speed is -1023 to +1023 Feed forward = 1023/4915.2 = .8333
     * 
     * Wheel diameter = 4 inches 4 * Pi = 12.57 inches per rev 12 inches /sec = 4096
     * counts/second 4096/1000 * 100 = 409.6 counts/100ms Cruise Velocity = 410
     * 
     * Plan on .25 seconds to accelerate and .25 to decelerate Acceleration = 205
     */

    public DriveTrainSRX() {

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        talonDriveLeft1 = new WPI_TalonFX(1);

        talonDriveLeft2 = new WPI_TalonFX(2);

        talonDriveRight1 = new WPI_TalonFX(3);

        talonDriveRight2 = new WPI_TalonFX(4);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        differentialDrive = new MMW_DifferentialDrive(talonDriveLeft1, talonDriveRight1);
        loadConfig(Robot.config);
        talonDriveLeft1.configFactoryDefault();
        talonDriveLeft1.configSelectedFeedbackSensor(FeedbackDevice.IntegratedSensor, pidSlot0, timeoutMs);
        talonDriveLeft1.setSensorPhase(true); // !!!! Check this !!!!!
        talonDriveLeft1.setInverted(false);
        talonDriveLeft1.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
        talonDriveLeft1.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector,
                LimitSwitchNormal.NormallyOpen, timeoutMs);
        talonDriveLeft1.configForwardSoftLimitEnable(false, timeoutMs);
        talonDriveLeft1.configReverseSoftLimitEnable(false, timeoutMs);
        talonDriveLeft1.clearStickyFaults(0);
        talonDriveLeft1.setIntegralAccumulator(0, pidSlot0, timeoutMs);
        talonDriveLeft1.setNeutralMode(NeutralMode.Brake);
        talonDriveLeft1.set(ControlMode.PercentOutput, 0);
        talonDriveLeft1.config_kP(pidSlot0, driveP, timeoutMs);
        talonDriveLeft1.config_kI(pidSlot0, driveI, timeoutMs);
        talonDriveLeft1.config_kD(pidSlot0, driveD, timeoutMs);
        talonDriveLeft1.config_kF(pidSlot0, driveF, timeoutMs);
        talonDriveLeft1.setSelectedSensorPosition(0, pidSlot0, timeoutMs);

        Constants.kGains_MotProf.setSlot(talonDriveLeft1, Constants.kSlot_MotProf);

        // talonDriveLeft1.setSafetyEnabled(false);

        talonDriveLeft2.configFactoryDefault();
        talonDriveLeft2.setInverted(false);
        talonDriveLeft2.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
        talonDriveLeft2.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector,
                LimitSwitchNormal.NormallyOpen, timeoutMs);
        talonDriveLeft2.configForwardSoftLimitEnable(false, timeoutMs);
        talonDriveLeft2.configReverseSoftLimitEnable(false, timeoutMs);
        talonDriveLeft2.clearStickyFaults(0);
        talonDriveLeft2.setIntegralAccumulator(0, pidSlot0, timeoutMs);
        talonDriveLeft2.setNeutralMode(NeutralMode.Brake);
        talonDriveLeft2.set(ControlMode.Follower, 1);
        /*
         * talonDriveLeft3.setInverted(false);
         * talonDriveLeft3.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
         * talonDriveLeft3.configForwardLimitSwitchSource(LimitSwitchSource.
         * FeedbackConnector, LimitSwitchNormal.NormallyOpen, timeoutMs);
         * talonDriveLeft3.configForwardSoftLimitEnable(false, timeoutMs);
         * talonDriveLeft3.configReverseSoftLimitEnable(false, timeoutMs);
         * talonDriveLeft3.clearStickyFaults(timeoutMs);
         * talonDriveLeft3.setIntegralAccumulator(0, pidSlot0, timeoutMs);
         * talonDriveLeft3.setNeutralMode(NeutralMode.Brake);
         * talonDriveLeft3.set(ControlMode.Follower, 0);
         */
        talonDriveRight1.configFactoryDefault();
        talonDriveRight1.configSelectedFeedbackSensor(FeedbackDevice.IntegratedSensor, pidSlot0, timeoutMs);
        talonDriveRight1.setSensorPhase(false); // !!!! Check this !!!!!
        talonDriveRight1.setInverted(true);
        talonDriveRight1.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
        talonDriveRight1.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector,
                LimitSwitchNormal.NormallyOpen, timeoutMs);
        talonDriveRight1.configForwardSoftLimitEnable(false, 0);
        talonDriveRight1.configReverseSoftLimitEnable(false, 0);
        talonDriveRight1.clearStickyFaults(0);
        talonDriveRight1.setIntegralAccumulator(0, pidSlot0, timeoutMs);
        talonDriveRight1.setNeutralMode(NeutralMode.Brake);
        talonDriveRight1.set(ControlMode.PercentOutput, 0);
        talonDriveRight1.config_kP(pidSlot0, driveP, timeoutMs);
        talonDriveRight1.config_kI(pidSlot0, driveI, timeoutMs);
        talonDriveRight1.config_kD(pidSlot0, driveD, timeoutMs);
        talonDriveRight1.config_kF(pidSlot0, driveF, timeoutMs);
        talonDriveRight1.setSelectedSensorPosition(0, pidSlot0, timeoutMs);
        // talonDriveRight1.setSafetyEnabled(false);

        Constants.kGains_MotProf.setSlot(talonDriveRight1, Constants.kSlot_MotProf);

        talonDriveRight2.configFactoryDefault();
        talonDriveRight2.setInverted(true);
        talonDriveRight2.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
        talonDriveRight2.configForwardLimitSwitchSource(LimitSwitchSource.FeedbackConnector,
                LimitSwitchNormal.NormallyOpen, timeoutMs);
        talonDriveRight2.configForwardSoftLimitEnable(false, 0);
        talonDriveRight2.configReverseSoftLimitEnable(false, 0);
        talonDriveRight2.clearStickyFaults(0);
        talonDriveRight2.setIntegralAccumulator(0, 0, 0);
        talonDriveRight2.setNeutralMode(NeutralMode.Brake);
        talonDriveRight2.set(ControlMode.Follower, 3);
        /*
         * talonDriveRight3.setInverted(true);
         * talonDriveRight3.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
         * talonDriveRight3.configForwardLimitSwitchSource(LimitSwitchSource.
         * FeedbackConnector, LimitSwitchNormal.NormallyOpen, timeoutMs);
         * talonDriveRight3.configForwardSoftLimitEnable(false, timeoutMs);
         * talonDriveRight3.configReverseSoftLimitEnable(false, timeoutMs);
         * talonDriveRight3.clearStickyFaults(0);
         * talonDriveRight3.setIntegralAccumulator(0, pidSlot0, timeoutMs);
         * talonDriveRight3.setNeutralMode(NeutralMode.Brake);
         * talonDriveRight3.set(ControlMode.Follower, 3);
         */
        /*
         * Additional settings for motion magic Left
         */
        /* Set relevant frame periods to be at least as fast as periodic rate */
        talonDriveLeft1.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, 0);
        talonDriveLeft1.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, 0);

        /* set the peak and nominal outputs */
        talonDriveLeft1.configNominalOutputForward(0, 0);
        talonDriveLeft1.configNominalOutputReverse(0, 0);
        talonDriveLeft1.configPeakOutputForward(1, 0);
        talonDriveLeft1.configPeakOutputReverse(-1, 0);

        /* set acceleration and vcruise velocity - see documentation */
        talonDriveLeft1.configMotionCruiseVelocity(cruiseVelocity, 0);
        talonDriveLeft1.configMotionAcceleration(acceleration, 0);

        /*
         * Additional settings for motion magic Right
         */

        /* Set relevant frame periods to be at least as fast as periodic rate */
        talonDriveRight1.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, 0);
        talonDriveRight1.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, 0);

        /* set the peak and nominal outputs */
        talonDriveRight1.configNominalOutputForward(0, 0);
        talonDriveRight1.configNominalOutputReverse(0, 0);
        talonDriveRight1.configPeakOutputForward(1, 0);
        talonDriveRight1.configPeakOutputReverse(-1, 0);

        /* set acceleration and vcruise velocity - see documentation */
        talonDriveRight1.configMotionCruiseVelocity(cruiseVelocity, 0);
        talonDriveRight1.configMotionAcceleration(acceleration, 0);

        pidgy = new PigeonIMU(20);
        pidgy.configFactoryDefault();

        //m_leftEncoder.setDistancePerPulse(DriveConstants.kEncoderDistancePerPulse);
        //m_rightEncoder.setDistancePerPulse(DriveConstants.kEncoderDistancePerPulse);
    
        resetEncoders();
        m_odometry = new DifferentialDriveOdometry(m_gyro.getRotation2d());
    }

    @Override
    public void periodic() {

        double max_vel = SmartDashboard.getNumber("Drive Vel", 100);
        double max_accel = SmartDashboard.getNumber("Drive Accel", 1000);

        setDriveSpeed(max_vel, max_accel);

    }

    public void tankDriveVolts(double leftVolts, double rightVolts) {
        talonDriveLeft1.setVoltage(leftVolts);
        talonDriveLeft2.setVoltage(leftVolts);
        talonDriveRight1.setVoltage(rightVolts);
        talonDriveRight2.setVoltage(rightVolts);
        differentialDrive.feed();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    /**
     * Limit motor values to the -1.0 to +1.0 range.
     */
    protected double limit(double value) {
        if (value > 1.0) {
            return 1.0;
        }
        if (value < -1.0) {
            return -1.0;
        }
        return value;
    }

    public double getDriveSpeed() {
        return 0.5 * (leftCurrentSpeed + rightCurrentSpeed);
    }

    protected double applyDeadband(double value, double deadband) {
        if (Math.abs(value) > deadband) {
            if (value > 0.0) {
                return (value - deadband) / (1.0 - deadband);
            } else {
                return (value + deadband) / (1.0 - deadband);
            }
        } else {
            return 0.0;
        }
    }

    /**
     * Arcade drive method for differential drive platform.
     *
     * @param xSpeed
     *            The robot's speed along the X axis [-1.0..1.0]. Forward
     *            is positive.
     * @param zRotation
     *            The robot's rotation rate around the Z axis [-1.0..1.0].
     *            Clockwise is positive.
     * @param squaredInputs
     *            If set, decreases the input sensitivity at low speeds.
     */
    public void arcadeDriveX(double xSpeed, double zRotation, boolean squaredInputs) {
        xSpeed = limit(xSpeed);
        xSpeed = applyDeadband(xSpeed, .01);

        // Flip the sign for steering
        zRotation = -limit(zRotation);
        zRotation = applyDeadband(zRotation, .01);

        // Square the inputs (while preserving the sign) to increase fine control
        // while permitting full power.
        if (squaredInputs) {
            xSpeed = Math.copySign(xSpeed * xSpeed, xSpeed);
            zRotation = Math.copySign(zRotation * zRotation, zRotation);
        }

        double leftMotorOutput;
        double rightMotorOutput;

        double maxInput = Math.copySign(Math.max(Math.abs(xSpeed), Math.abs(zRotation)), xSpeed);

        if (xSpeed >= 0.0) {
            // First quadrant, else second quadrant
            if (zRotation >= 0.0) {
                leftMotorOutput = maxInput;
                rightMotorOutput = xSpeed - zRotation;
            } else {
                leftMotorOutput = xSpeed + zRotation;
                rightMotorOutput = maxInput;
            }
        } else {
            // Third quadrant, else fourth quadrant
            if (zRotation >= 0.0) {
                leftMotorOutput = xSpeed + zRotation;
                rightMotorOutput = maxInput;
            } else {
                leftMotorOutput = maxInput;
                rightMotorOutput = xSpeed - zRotation;
            }
        }

        differentialDrive.tankDrive(-leftMotorOutput, rightMotorOutput, false);
    }

    public void setDriveSpeed(double max_vel, double max_accel) {
        driver_max_velocity = Math.max(50, Math.min(500, max_vel));
        driver_max_accel = Math.max(300, Math.min(3000, max_accel));

        SmartDashboard.putNumber("Drive Vel", driver_max_velocity);
        SmartDashboard.putNumber("Drive Accel", driver_max_accel);
    }

    public void gameVelocityDrive(XboxController joy) {
        lastJoyLeft = joy.getRightY();
        lastJoyRight = joy.getLeftY();

        lastJoyRight = (lastJoyRight * lastJoyRight) * (lastJoyRight > 0 ? 1 : -1);
        lastJoyLeft = (lastJoyLeft * lastJoyLeft) * (lastJoyLeft > 0 ? 1 : -1);

        boolean fast = joy.getRawButton(5);
        if (fast) {
            // drive straight -- fast!!!
            lastJoyRight = 0.5 * (lastJoyRight + lastJoyLeft);
            lastJoyLeft = lastJoyRight;
        } else {
            // reduce difference
            double ave = (lastJoyRight + lastJoyLeft) / 2;
            double diff = (lastJoyRight - lastJoyLeft);
            if (Math.abs(ave) > 0.5) {
                // faster is straighter
                diff = diff * (1 - Math.abs(ave));
            } else {
                diff = diff * 0.5;
            }
            diff *= 0.6; // even less sensitive
            lastJoyRight = ave + diff;
            lastJoyLeft = ave - diff;
        }

        double accel_per_period = driver_max_accel * Robot.kDefaultPeriod;
        leftCurrentSpeed = limitAccel(accel_per_period, leftCurrentSpeed, lastJoyLeft * driver_max_velocity);
        rightCurrentSpeed = limitAccel(accel_per_period, rightCurrentSpeed, lastJoyRight * driver_max_velocity);

        // set drive velocity
        talonDriveLeft1.set(ControlMode.Velocity, leftCurrentSpeed * SPEED_SCALE);
        talonDriveRight1.set(ControlMode.Velocity, rightCurrentSpeed * SPEED_SCALE);

        pingDifferentialDrive();
    }

    /*
     * Used for single joystick device using X and Y
     */
    // public void arcadeDrive(XboxController driveJoy) {
    // accumSpeed = 0;
    // lastJoyLeft = driveJoy.getLeftY();
    // lastJoyRight = driveJoy.getRightY();
    // // differentialDrive.arcadeDrive(joy.getY(), joy.getX(), true);
    // arcadeDriveX(lastJoyLeft, lastJoyRight, joySquare);
    // lastDriveMode = "ArcadeJoy";
    // }

    /*
     * Arcade drive using game pad axis 5 as direction
     */
    public void arcadeDrive(XboxController driveJoy) {
        accumSpeed = 0;
        lastJoyLeft = driveJoy.getLeftY(); // speed
        lastJoyRight = driveJoy.getRightX(); // rotation
        // The values to pass to the motors are adjusted by the ramp method
        leftCurrentSpeed = returnRamp(leftCurrentSpeed, lastJoyLeft);
        rightCurrentSpeed = returnRamp(rightCurrentSpeed, lastJoyRight);
        // SmartDashboard.putNumber("LJoyY", lastJoyLeft);
        // SmartDashboard.putNumber("LCurrentSpeed", leftCurrentSpeed);
        // differentialDrive.arcadeDrive(leftCurrentSpeed, rightCurrentSpeed, true);
        arcadeDriveX(leftCurrentSpeed, rightCurrentSpeed, joySquare);
        lastDriveMode = "ArcadeJoy";
    }

    /*
     * Arcade drive using values for speed and direction
     */
    public void arcadeDrive(double speed, double direction) {
        velocityDrive(speed, direction);
        lastJoyLeft = speed;
        lastJoyRight = direction;
        lastDriveMode = "Arcade";
    }

    /*
     * Arcade style drive using the gyro for feed back
     * 
     * Special case: If the speed is zero, take the speed from the left joy stick.
     */

    public void gyroDrive(double speed, double angle) {
        double steer = (Robot.gyro.getAngle() - angle);
        if (steer > 180) {
            steer = steer - 360;
        } else if (steer < -180) {
            steer = steer + 360;
        }
        steer *= -Robot.gyro.gyroP;

        if (steer > Robot.gyro.gyroTurnMax) {
            steer = Robot.gyro.gyroTurnMax;
        } else if (steer < -Robot.gyro.gyroTurnMax) {
            steer = -Robot.gyro.gyroTurnMax;
        }
        lastDriveMode = "Gyro";
        if (speed == 0) {
            // Use the joystick or stop if centered
            // Robot.drivetrain.arcadeDrive(Robot.oi.driveRight.getY(), steer);
            // velocityDrive(Robot.oi.driveRight.getY(), steer);
            // robotDrive.arcadeDrive(Robot.oi.driveRight.getY(), steer);
            // differentialDrive.arcadeDrive(Robot.oi.driveJoy.getY(), steer);
            lastJoyLeft = Robot.oi.driveJoy.getLeftY();
            arcadeDriveX(lastJoyLeft, steer, false);
        } else {
            // Robot.drivetrain.arcadeDrive(speed, steer);
            velocityDrive(speed, steer);
            lastJoyLeft = speed;
            lastJoyRight = steer;
        }
    }

    /*
     * Used by other methods for sort of PID speed control
     */
    public void velocityDrive(double speed, double direction) {
        double rateError;
        double finalSpeed;
        double averageRate;
        finalSpeed = 0;
        speed /= 10;
        if (Math.abs(speed) < .01)
            speed = 0;
        if (speed == 0) {
            accumSpeed = 0;
        } else {
            if (accumSpeed == 0) {
                accumSpeed = (speed > 0) ? speedFeedForward : -speedFeedForward;
            }

            averageRate = getAverageRate();
            rateError = speed + averageRate / 300;
            accumSpeed += rateError * SPEED_I;
            if (accumSpeed > .7) {
                accumSpeed = .7;
            } else if (accumSpeed < -.7) {
                accumSpeed = -.7;
            }
            finalSpeed = accumSpeed + rateError * SPEED_P;
            // SmartDashboard.putNumber("rateError", rateError);
            // SmartDashboard.putNumber("accumSpeed", accumSpeed);
        }

        // differentialDrive.arcadeDrive(finalSpeed, direction);
        arcadeDriveX(finalSpeed, direction, false);
        lastJoyLeft = finalSpeed;
        lastJoyRight = direction;
        lastDriveMode = "Velocity";
    }

    /*
     * Method for driving a fixed distance straight This may get expanded to steer
     * as well. For now it's a test to used motion magic to drive
     */
    public void goToUsingMM(double speed, int distance, double direction) {
        int distanceAsCounts;

        // convert absolute distance into absolute encoder counts
        distanceAsCounts = (int) Math.round(distance * COUNTS_PER_INCH);

        // for now reset encoders to make debugging easier
        // May not want to do this in the final code.
        // resetEncoders();
        // resetEncoders();
        /*
         * Get the current encoder counts and convert distance counts to relative counts
         * It may be better to reset the counters.
         */
        // Dont reset the counters since it is not reliable
        finalLeft = distanceAsCounts + getLeftEncoder();
        finalRight = distanceAsCounts + getRightEncoder();

        // Reset the speed in case someone else changed it.
        talonDriveLeft1.configMotionCruiseVelocity(cruiseVelocity, 0);
        talonDriveRight1.configMotionCruiseVelocity(cruiseVelocity, 0);
        talonDriveLeft1.configMotionAcceleration(acceleration, 0);
        talonDriveLeft1.configMotionAcceleration(acceleration, 0);
        talonDriveLeft1.set(ControlMode.MotionMagic, finalLeft);
        talonDriveRight1.set(ControlMode.MotionMagic, finalRight);
        stuckCount = 0;
        /*
         * Will need to disable motorSafetyHepler when not using differentialDrive Calls
         */
        // SmartDashboard.putNumber("FinalRight", finalRight);
        // SmartDashboard.putNumber("Distance in Counts", distanceAsCounts);
    }

    public void goToUsingMM(double leftDistance, double rightDistance) {
        int distanceAsCountsLeft;
        int distanceAsCountsRight;
        int leftCruiseVelocity = cruiseVelocity;
        int rightCruiseVelocity = cruiseVelocity;
        int leftAccel = acceleration;
        int rightAccel = acceleration;
        double distanceRatio;

        // convert absolute distance into absolute encoder counts
        distanceAsCountsLeft = (int) Math.round(leftDistance * COUNTS_PER_INCH);
        distanceAsCountsRight = (int) Math.round(rightDistance * COUNTS_PER_INCH);

        // Don't reset the counters since it is not reliable
        finalLeft = distanceAsCountsLeft + getLeftEncoder();
        finalRight = distanceAsCountsRight + getRightEncoder();

        // Now adjust the speed for the distance difference
        distanceAsCountsLeft = Math.abs(distanceAsCountsLeft);
        distanceAsCountsRight = Math.abs(distanceAsCountsRight);

        if (distanceAsCountsLeft < distanceAsCountsRight) {
            distanceRatio = (double) distanceAsCountsLeft / (double) distanceAsCountsRight;
            leftCruiseVelocity = (int) Math.round(cruiseVelocity * distanceRatio);
            leftAccel = (int) Math.round(acceleration * distanceRatio);
        } else if (distanceAsCountsRight < distanceAsCountsLeft) {
            distanceRatio = (double) distanceAsCountsRight / (double) distanceAsCountsLeft;
            rightCruiseVelocity = (int) Math.round(cruiseVelocity * distanceRatio);
            rightAccel = (int) Math.round(acceleration * distanceRatio);
        }

        // Reset the speed in case someone else changed it.
        // SmartDashboard.putNumber("FinalRight", finalRight);
        // SmartDashboard.putNumber("Distance in Counts", distanceAsCountsRight);
        talonDriveLeft1.configMotionCruiseVelocity(leftCruiseVelocity, 0);
        talonDriveRight1.configMotionCruiseVelocity(rightCruiseVelocity, 0);

        talonDriveLeft1.configMotionAcceleration(leftAccel, 0);
        talonDriveRight1.configMotionAcceleration(rightAccel, 0);

        talonDriveLeft1.set(ControlMode.MotionMagic, finalLeft);
        talonDriveRight1.set(ControlMode.MotionMagic, finalRight);
        stuckCount = 0;
    }

    public void goToUsingMM(double leftDistance, double rightDistance, boolean newStart, int accel, int vel) {
        if (newStart) {
            // start move from current location
            lastEndDistanceLeft = getLeftDistance();
            lastEndDistanceRight = getRightDistance();
        }

        // update the last distance to include this move
        lastEndDistanceLeft += leftDistance;
        lastEndDistanceRight += rightDistance;

        // update the final count target for this move
        finalLeft = (int) Math.round(lastEndDistanceLeft * COUNTS_PER_INCH);
        finalRight = (int) Math.round(lastEndDistanceRight * COUNTS_PER_INCH);

        // get absolute magnitude of the move
        leftDistance = Math.abs(leftDistance);
        rightDistance = Math.abs(rightDistance);

        // check for default accel/vel
        if (accel <= 0)
            accel = acceleration;
        if (vel <= 0)
            vel = cruiseVelocity;

        // scale the accel/vel to match the magnitude of the moves
        int leftCruiseVelocity = vel;
        int rightCruiseVelocity = vel;
        int leftAccel = accel;
        int rightAccel = accel;
        double distanceRatio;

        if (leftDistance < rightDistance) {
            distanceRatio = (double) leftDistance / (double) rightDistance;
            leftCruiseVelocity = (int) Math.round(vel * distanceRatio);
            leftAccel = (int) Math.round(accel * distanceRatio);
        } else if (rightDistance < leftDistance) {
            distanceRatio = (double) rightDistance / (double) leftDistance;
            rightCruiseVelocity = (int) Math.round(vel * distanceRatio);
            rightAccel = (int) Math.round(accel * distanceRatio);
        }

        // Reset the speed in case someone else changed it.
        // SmartDashboard.putNumber("FinalRight", finalRight);
        // SmartDashboard.putNumber("Distance in Counts", distanceAsCountsRight);
        talonDriveLeft1.configMotionCruiseVelocity(leftCruiseVelocity, 0);
        talonDriveRight1.configMotionCruiseVelocity(rightCruiseVelocity, 0);

        talonDriveLeft1.configMotionAcceleration(leftAccel, 0);
        talonDriveRight1.configMotionAcceleration(rightAccel, 0);

        talonDriveLeft1.set(ControlMode.MotionMagic, finalLeft);
        talonDriveRight1.set(ControlMode.MotionMagic, finalRight);
        stuckCount = 0;
    }

    public void goTo(double leftDistance, double rightDistance) {
        int distanceAsCountsLeft;
        int distanceAsCountsRight;

        // convert absolute distance into absolute encoder counts
        distanceAsCountsLeft = (int) Math.round(leftDistance * COUNTS_PER_INCH);
        distanceAsCountsRight = (int) Math.round(rightDistance * COUNTS_PER_INCH);

        // Don't reset the counters since it is not reliable
        finalLeft = distanceAsCountsLeft + getLeftEncoder();
        finalRight = distanceAsCountsRight + getRightEncoder();

        talonDriveLeft1.set(ControlMode.Position, finalLeft);
        talonDriveRight1.set(ControlMode.Position, finalRight);
        stuckCount = 0;
    }

    public void goToDistance(double leftDistance, double rightDistance) {
        // convert absolute distance into absolute encoder counts
        int distanceAsCountsLeft = (int) Math.round(leftDistance * COUNTS_PER_INCH);
        int distanceAsCountsRight = (int) Math.round(rightDistance * COUNTS_PER_INCH);

        talonDriveLeft1.set(ControlMode.Position, distanceAsCountsLeft);
        talonDriveRight1.set(ControlMode.Position, distanceAsCountsRight);
        stuckCount = 0;
    }

    public void pingDifferentialDrive() {
        differentialDrive.pingMotorSafety();
    }

    /*
     * Method to go with the above move used to determine when the move has
     * completed
     */
    public boolean moveComplete(int maxPositionError) {
        if (maxPositionError <= 0) {
            maxPositionError = MAX_POSITION_ERROR;
        }

        int leftEncoder = getLeftEncoder();
        int rightEncoder = getRightEncoder();
        boolean leftGood = Math.abs(finalLeft - leftEncoder) < maxPositionError;
        boolean rightGood = Math.abs(finalRight - rightEncoder) < maxPositionError;

        boolean stuck = false;
        if (stuckStartCount < STUCK_START_IGNORE) {
            stuckStartCount++;
        } else if (stuckCount < STUCK_MAX_COUNT) {
            stuckCount++;
            if (Math.abs(lastLeftCount - leftEncoder) > STUCK_ENCODER_LIMIT
                    || Math.abs(lastRightCount - rightEncoder) > STUCK_ENCODER_LIMIT) {
                stuckCount = 0;
            }
        } else {
            stuck = true;
        }

        lastLeftCount = leftEncoder;
        lastRightCount = rightEncoder;
        // SmartDashboard.putNumber("TalonDriveRight position", finalRight);
        // SmartDashboard.putBoolean("Right Good", rightGood);
        // SmartDashboard.putBoolean("Left Good", leftGood);
        // --SmartDashboard.putNumber("Left Error", finalLeft - leftEncoder);
        // --SmartDashboard.putNumber("Right Error", finalRight - rightEncoder);
        // --SmartDashboard.putBoolean("Drive Stuck", stuck);
        return stuck || (leftGood && rightGood);
    }

    public boolean moveComplete() {
        return moveComplete(0);
    }

    /*
     * Returns the average encoder rate of left and right
     */
    public double getAverageRate() {
        double rightRate, leftRate, averageRate;

        rightRate = talonDriveRight1.getSelectedSensorVelocity(0);
        leftRate = talonDriveLeft1.getSelectedSensorVelocity(0);
        averageRate = (leftRate + rightRate) / 2;
        return averageRate;
    }

    /*
     * Tank drive using game pad where right comes from axis 5
     */
    public void tankDrive(XboxController driveJoy) {
        accumSpeed = 0;
        lastJoyLeft = driveJoy.getLeftY();
        lastJoyRight = driveJoy.getRightY();

        // The values to pass to the motors are adjusted by the ramp method
        leftCurrentSpeed = returnRamp(leftCurrentSpeed, lastJoyLeft);
        rightCurrentSpeed = returnRamp(rightCurrentSpeed, lastJoyRight);
        // SmartDashboard.putNumber("LSpeed", leftCurrentSpeed);
        // SmartDashboard.putNumber("RSpeed", rightCurrentSpeed);
        // SmartDashboard.putNumber("lastJoyLeft", lastJoyLeft);
        differentialDrive.tankDrive(-rightCurrentSpeed, leftCurrentSpeed, joySquare);
        lastDriveMode = "Tank";
    }

    /*
     * Stop the robot
     */
    public void driveStop() {
        differentialDrive.tankDrive(0, 0);
        accumSpeed = 0;
    }

    /*
     * Set the max voltage to the drive train The joystick values will be scaled by
     * this value
     */
    public void setMax() {
        differentialDrive.setMaxOutput(drivetrainVoltageLimit);
    }

    double limitAccel(double accel, double currentSpeed, double desiredSpeed) {
        double delta = desiredSpeed - currentSpeed;

        if (delta > accel) {
            delta = accel;
        } else if (delta < -accel) {
            delta = -accel;
        }
        return (currentSpeed + delta);
    }

    // This method performs the ramp calculation for the drive train
    double returnRamp(double currentSpeed, double desiredSpeed) {
        double delta = desiredSpeed - currentSpeed;

        if (delta > rampIncrement) {
            delta = rampIncrement;
        } else if (delta < -rampIncrement) {
            delta = -rampIncrement;
        }
        return (currentSpeed + delta);
    }

    public int getRightEncoder() {
        return (int) talonDriveRight1.getSelectedSensorPosition(0);
    }

    public int getLeftEncoder() {
        return (int) talonDriveLeft1.getSelectedSensorPosition(0);
    }

    public double getRightDistance() {
        return (double) getRightEncoder() / COUNTS_PER_INCH;
    }

    public double getLeftDistance() {
        return (double) getLeftEncoder() / COUNTS_PER_INCH;
    }

    public int getLeftEncoderVelocity() {
        return (int) talonDriveLeft1.getSelectedSensorVelocity(0);
    }

    public int getRightEncoderVelocity() {
        return (int) talonDriveRight1.getSelectedSensorVelocity(0);
    }

    public double getLeftVelocity() {
        return talonDriveLeft1.getSelectedSensorVelocity(0) / SPEED_SCALE;
    }

    public double getRightVelocity() {
        return talonDriveRight1.getSelectedSensorVelocity(0) / SPEED_SCALE;
    }

    public void resetEncoders() {
        talonDriveLeft1.setSelectedSensorPosition(0, 0, 10);
        talonDriveRight1.setSelectedSensorPosition(0, 0, 10);
    }

    public void addTelemetryHeaders() {

        // Robot.currentMonitor.registerMonitorDevive(talonDriveLeft1, "Drive Left 1");
        // Robot.currentMonitor.registerMonitorDevive(talonDriveLeft2, "Drive Left 2");
        // Robot.currentMonitor.registerMonitorDevive(talonDriveLeft3, "Drive Left 3");
        // Robot.currentMonitor.registerMonitorDevive(talonDriveRight1, "Drive Right
        // 1");
        // Robot.currentMonitor.registerMonitorDevive(talonDriveRight2, "Drive Right
        // 2");
        // Robot.currentMonitor.registerMonitorDevive(talonDriveRight3, "Drive Right
        // 3");
        Robot.telem.addColumn("Drive Left");
        Robot.telem.addColumn("Drive Right");
        Robot.telem.addColumn("Drive Mode");

        Robot.telem.addColumn("Left Distance");
        Robot.telem.addColumn("Right Distance");

        // Robot.telem.addColumn("Left Target");
        // Robot.telem.addColumn("Right Target"); }
    }

    public void writeTelemetry() {
        if (Robot.isTelemetryEnbled) {
            Robot.telem.saveDouble("Drive Left", lastJoyLeft);
            Robot.telem.saveDouble("Drive Right", lastJoyRight);
            Robot.telem.saveString("Drive Mode", lastDriveMode);
            Robot.telem.saveDouble("Left Distance", getLeftDistance());
            Robot.telem.saveDouble("Right Distance", getRightDistance());
        }

        // Robot.telem.saveDouble("Left Target", talonDriveLeft1.getClosedLoopTarget(0)
        // / COUNTS_PER_INCH);
        // Robot.telem.saveDouble("Right Target",
        // talonDriveRight1.getClosedLoopTarget(0) / COUNTS_PER_INCH);
    }

    public void loadConfig(Config config) {
        drivetrainVoltageLimit = config.getDouble("SRXDriveVLimit", Defaults.DRIVETRAIN_VOLTAGE_LIMIT_DEFAULT);
        setMax();
        rampIncrement = config.getDouble("SRXDriveRampIncrement", Defaults.DRIVETRAIN_RAMP_INCREMENT);
        driveP = config.getDouble("SRXDriveP", Defaults.DRIVETRAIN_P);
        driveI = config.getDouble("SRXDriveI", Defaults.DRIVETRAIN_I);
        driveD = config.getDouble("SRXDriveD", Defaults.DRIVETRAIN_D);
        driveF = config.getDouble("SRXDriveF", Defaults.DRIVETRAIN_F);
        cruiseVelocity = config.getInt("SRXCruiseVelocity", Defaults.DRIVE_CRUISEVELOCITY);
        acceleration = config.getInt("SRXAcceleration", Defaults.DRIVE_ACCELERATION);
        joySquare = config.getBoolean("SRXDriveJoystickSquare", Defaults.DRIVE_JOYSQUARE);
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new GamePadDrive());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    public TalonFX getTalonFXLeft1() {
        return talonDriveLeft1;
    }

    public TalonFX getTalonFXRight1() {
        return talonDriveRight1;
    }

    public void motionProfileStop() {
        // stop/clear MotionProfile
        motionProfileSetValue(SetValueMotionProfile.Disable);
        talonDriveLeft1.clearMotionProfileTrajectories();
        talonDriveRight1.clearMotionProfileTrajectories();
    }

    public void motionProfileSetValue(SetValueMotionProfile cmd) {
        talonDriveLeft1.set(TalonFXControlMode.MotionProfile, cmd.value);
        talonDriveRight1.set(TalonFXControlMode.MotionProfile, cmd.value);
    }

    // Jacob's Trajectory
    public void resetOdometry(Pose2d pose) {
        resetEncoders();
        m_odometry.resetPosition(pose, m_gyro.getRotation2d());
    }

    public double getHeading() {
        return m_gyro.getRotation2d().getDegrees();
    }

    public Pose2d getPose() {
        return m_odometry.getPoseMeters();
    }
}
