package org.usfirst.frc2016.subsystems;

import org.usfirst.frc2016.utils.*;
import org.usfirst.frc2016.commands.*;
import org.usfirst.frc2016.Robot;

import org.usfirst.frc2016.Config;
import org.usfirst.frc2016.Constants;
import org.usfirst.frc2016.Defaults;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;

public class BallIntake extends Subsystem {

    private MotorBase arm;
    private MotorBase brush;

    private Timer tmrStall = new Timer();

    private double stopSeconds = 0.250;
    private double liftStallVel = 0.1;
    private double stallSec = 0.1;

    public BallIntake() {

        brush = new MotorNeo("IntakeBrush", "", Constants.DeviceId.intakeBrush, 0, true);
        brush.setDisplayFormats(2, 3, 3, 0);

        arm = new MotorNeo("IntakeArm", "", Constants.DeviceId.intakeArm, 0, true);
        arm.setDisplayFormats(2, 3, 3, 0);

        tmrStall.start();
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        //checkLift();
        //operatorBrushPov();
    }

    /**
     * check the lift for stalled
     */
    public void checkLift() {
        if (Math.abs(arm.getMotorPwr()) > 0.0) {
            // motr is running
            if (Math.abs(arm.getMotorVel()) > liftStallVel) {
                // still moving, reset the stall timer
                tmrStall.reset();
            } else {
                // not moving, check stall timer
                if (tmrStall.get() > stallSec) {
                    // has not moved, stop
                    arm.stop();
                }
            }
        }
    }

    /**
     * control the brush from the operator POV
     */
    public void operatorBrushPov() {
        if (!Robot.autoPilotRobot.isFinished())
            return;

        double pwr = 0;
        int pov = Robot.oi.operatorJoy.getPOV();
        switch (pov) {

            case -1: // This is the case where the POV is centered, stop the wheels here
                pwr = 0;
                break;

            case 0: // POV is pressed forward, cause the cube to move away from the bot.
                pwr = -brush.getMoveVel();
                break;

            case 180: // POV is back, cause the cube to move toward the bot.
                pwr = brush.getMoveVel();
                break;

            default: // other states not covered above, keep current speed
                pwr = brush.getMotorPwr();
                break;
        }

        if (pwr != brush.getMotorPwr()) {
            brush.moveByPower(pwr);
        }
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void stop() {
        arm.stop();
        brush.stop();
    }

    public void brushStop() {
        brush.stop();
    }

    public void brushIn() {
        brush.moveByPower(1/*brush.getMoveVel()*/);
    }

    public void brushOut() {
        brush.moveByPower(-brush.getMoveVel());
    }

    public void brushSlower() {
        brush.slowerPower(stopSeconds);
    }

    public boolean brushStopped() {
        return Math.abs(brush.getMotorPwr()) < .01;
    }

    public void armStop() {
        arm.stop();
    }

    public void armDown() {
        tmrStall.reset();
        tmrStall.start();
        arm.zeroMotorPos();
        arm.moveByPower(-arm.getMoveVel());
    }

    public void armUp() {
        tmrStall.reset();
        tmrStall.start();
        arm.zeroMotorPos();
        arm.moveByPower(arm.getMoveVel());
    }
}
