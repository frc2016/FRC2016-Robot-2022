// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2016.subsystems;

import edu.wpi.first.wpilibj.command.Subsystem;
import oi.limelightvision.limelight.frc.*;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
//import com.granitecitygearhead.frc3244.limelightlib.LimeLight;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Limelight extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    private boolean limelightHasValidTarget = false;
    public double steerCommand = 0.0;
    public double driveCommand = 0.0;

    /* [CONSTANTS] */
    // These must be tuned for each pipeline. Set them when you instantiate the
    // LimelightCamera object
    private double STEER_K; // How hard to steer towards target
    private double DRIVE_K; // How hard to drive forward towards target
    private double DESIRED_TARGET_AREA; // Area of target when robot reaches wall
    private double MAX_SPEED; // Speed limit

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private LimeLight limeLightDevice;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public Limelight() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        limeLightDevice = new LimeLight("limelight");

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public LimeLight getLimeLight() {
        return limeLightDevice;
    }

    public void updateTracking() {
        limelightHasValidTarget = limeLightDevice.getIsTargetFound(); // Determine whether limelight has a valid target

        if (limelightHasValidTarget) { // If target is acquired

            // Calculate proportional steering
            double horizontalOffset = limeLightDevice.getdegRotationToTarget();
            steerCommand = horizontalOffset * STEER_K;

            // Drive forward until target area is at our desired area
            double targetArea = limeLightDevice.getTargetArea();
            driveCommand = (DESIRED_TARGET_AREA - targetArea) * DRIVE_K;
            if (driveCommand > MAX_SPEED) { // If max speed is exceeded
                driveCommand = MAX_SPEED; // Set drive command to speed limit
            }
        } else { // If no target is acquired
            driveCommand = 0.0; // Have the robot remain still
            steerCommand = 0.3;
        }
    }

    public void setDrive(double steer, double drive, double desiredTargetArea, double maxSpeed) {
        STEER_K = steer;
        DRIVE_K = drive;
        DESIRED_TARGET_AREA = desiredTargetArea;
        MAX_SPEED = maxSpeed;
    }

    public void findTargetStart() {
        limeLightDevice.setLEDMode(ControlMode.LedMode.kforceOn);
    }

    public void findTargetStop() {
        limeLightDevice.setLEDMode(ControlMode.LedMode.kforceOff);
    }

}
