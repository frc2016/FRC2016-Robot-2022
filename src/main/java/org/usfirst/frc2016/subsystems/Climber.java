package org.usfirst.frc2016.subsystems;

import org.usfirst.frc2016.utils.*;
import org.usfirst.frc2016.commands.*;
import org.usfirst.frc2016.Robot;

import org.usfirst.frc2016.Config;
import org.usfirst.frc2016.Constants;
import org.usfirst.frc2016.Defaults;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.XboxController;

public class Climber extends Subsystem {

    private MotorBase motorLeft;
    private MotorBase motorRight;
    private MotorBase motorFlop;

    private double currentSpeed = 0;
    private double deadband = 0.1;

    public Climber() {

        // MotorFalcon(String configName, String instanceName, int devId, int followId, boolean inverted)

        double liftCountsPerInch = 1200; // ???

        motorLeft = new MotorFalcon("Hang", "Left", Constants.DeviceId.hangLeft, 0, false);
        motorLeft.setUnits("in", liftCountsPerInch);

        motorRight = new MotorFalcon("Hang", "Right", Constants.DeviceId.hangRight, 0, true); 
        motorRight.setUnits("in", liftCountsPerInch);

        motorFlop = new MotorNeo("Flop", "", Constants.DeviceId.hangFlop, 0, true);
        motorFlop.setDisplayFormats(2, 3, 3, 0);
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
        setDefaultCommand(new ClimberDrive());
    }

    @Override
    public void periodic() {
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void stop() {
        motorLeft.stop();
        motorRight.stop();
        motorFlop.stop();
    }

    public void flopStop() {
        motorFlop.stop();
    }

    public void flopOut() {
        // motorFlop.moveByPower(motorFlop.getMoveVel());
        motorFlop.moveByPower(0.2);
    }

    public void flopIn() {
        // motorFlop.moveByPower(-motorFlop.getMoveVel());
        motorFlop.moveByPower(-0.2);
    }

    public void flopByPower(double fraction) {
        motorFlop.moveByPower(fraction);
    }

    public void extendByPower(double fractionLeft, double fractionRight) {
        driveClimber(); // test

        motorLeft.moveByPower(fractionLeft);
        motorRight.moveByPower(fractionRight);
    }

    public void driveClimber() {
        XboxController joy = Robot.oi.operatorJoy;
        double maxSpeed = 1.0;

        // get arm spped from up/down on right stick
        double joySpeed = applyDeadband(joy.getRightY());
        // get adjust from left/right in left stick
        double joyLevel = applyDeadband(joy.getLeftX());
        // get flop from triggers left in / right out
        double joyFlop = applyDeadband(joy.getLeftTriggerAxis() - joy.getRightTriggerAxis());

        SmartDashboard.putNumber("Joy left", joySpeed);
        SmartDashboard.putNumber("Joy Right", joyLevel);
        SmartDashboard.putNumber("Joy Flop", joyFlop);

        double accel_per_period = motorLeft.getMoveAccel() * Robot.kDefaultPeriod;
        //currentSpeed = limitAccel(accel_per_period, currentSpeed, joySpeed * maxSpeed);
        currentSpeed = joySpeed;

        double leftSpeed = currentSpeed - 0.5 * maxSpeed * joyLevel;
        double rightSpeed = currentSpeed + 0.5 * maxSpeed * joyLevel;

        SmartDashboard.putNumber("Lift left", leftSpeed);
        SmartDashboard.putNumber("Lift Right", rightSpeed);
        SmartDashboard.putNumber("Lift Flop", joyFlop);

        motorLeft.moveByPower(leftSpeed);
        motorRight.moveByPower(rightSpeed);
        motorFlop.moveByPower(joyFlop);
    }

    double applyDeadband(double joyValue) {
        // save sign
        double sign = (joyValue > 0) ? 1 : -1;
        // abd
        joyValue = Math.abs(joyValue);
        // apply deadband: below dead = 0, above scaled 0-1
        joyValue = (joyValue < deadband) ? 0 : (joyValue - deadband) / (1 - deadband);
        // square and apply sign
        joyValue = joyValue * joyValue * sign;
        return joyValue;
    }

    double limitAccel(double accel, double currentSpeed, double desiredSpeed) {
        double delta = desiredSpeed - currentSpeed;

        if (delta > accel) {
            delta = accel;
        } else if (delta < -accel) {
            delta = -accel;
        }
        return (currentSpeed + delta);
    }

}
